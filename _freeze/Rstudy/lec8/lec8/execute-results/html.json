{
  "hash": "b1f2074b792111712959227e872d2dc3",
  "result": {
    "markdown": "---\ntitle: Lecture 8 \ndate: '2023-01-08'\ndescription: 'matrix(1)'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n### 차례\n\n-   매트릭스 만들기: dim() , matrix()\n\n-   매트릭스 index : \\[ \\] 사용\n\n-   매트릭스 게산 : 단순 계산 / 행렬 계산\n\n-   매트릭스 이름 짓기 : rownames( ), colnames( )\n\n-   매트릭스 pre - allocate\n\n1.  **매트릭스 만들기 : dim( )**\n\n-   dim( )\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:4\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\n# 2행 2열 matrix \ndim(a) <- c(2,2)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\nclass(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n\n-   matrix(벡터, nrow, ncol)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2행 4열\nm <- matrix(1:8, nrow = 2, ncol = 4)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n:::\n\n```{.r .cell-code}\ndim(m) # 2행4열 의미 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n:::\n\n\n-   byrow = T 옵션(default = F) : 1행 기준으로 먼저 채우기\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:8, nrow = 2, ncol = 4) # 1열 기준으로 채우기 \nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n:::\n\n```{.r .cell-code}\nm <- matrix(1:8, nrow = 2, ncol = 4, byrow = T) # 1행 기준으로 채우기\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n```\n:::\n:::\n\n\n2.  매트릭스index : \\[ \\] 사용\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:8,nrow = 2, ncol = 4)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n:::\n\n```{.r .cell-code}\n# 1행 index\nm[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5 7\n```\n:::\n\n```{.r .cell-code}\n# 1열 index\nm[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n\n```{.r .cell-code}\n# 1행 1열 index\nm[1,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n# 2행 3열 index\nm[2,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n# 1열뺴고 전부인 index\nm[,-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    3    5    7\n[2,]    4    6    8\n```\n:::\n\n```{.r .cell-code}\n# 1행빼고 전부인 index\nm[-1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 8\n```\n:::\n:::\n\n\n-   복수 행, 열 index\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1,2열 index\nm[,1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\n# 1,3열 index\nm[,c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n```\n:::\n:::\n\n\n3.  매트릭스 계산 : 단순 계산 / 행렬 계산\n\n**단순계산 : 각 위치별 계산 적용**\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- matrix(c(1,2,3,4),2,2) # 2행 2열 matrix\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\nb <- matrix(c(5,6,7,8),2,2)\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n```\n:::\n\n```{.r .cell-code}\na + b \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    6   10\n[2,]    8   12\n```\n:::\n\n```{.r .cell-code}\na - b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   -4   -4\n[2,]   -4   -4\n```\n:::\n\n```{.r .cell-code}\na * b \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    5   21\n[2,]   12   32\n```\n:::\n\n```{.r .cell-code}\na / b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          [,1]      [,2]\n[1,] 0.2000000 0.4285714\n[2,] 0.3333333 0.5000000\n```\n:::\n:::\n\n\n**행렬 계산**\n\n-   행렬의 곱 : %\\*%\n\n-   diag(A) : 대각원소 뽑기, 벡터의 형태로 추출\n\n-   diag(2) : 2 by 2 단위 행렬 생성\n\n-   t(A) : 트랜스포스 --\\> 행과 열을 바꾸는 것. 전치행렬\n\n-   det(A) : 행렬식 구해줌 \\<Determinant(ad-bc)\\>\n\n-   solve(A) : 역행렬\n\n\n::: {.cell}\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\ndiag(a) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4\n```\n:::\n\n```{.r .cell-code}\ndiag(2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n:::\n\n```{.r .cell-code}\nt(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n```\n:::\n\n```{.r .cell-code}\ndet(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2\n```\n:::\n\n```{.r .cell-code}\nsolve(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n```\n:::\n\n```{.r .cell-code}\na;b # a행렬과 b 행렬 붙이기\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n```\n:::\n\n```{.r .cell-code}\na %*% b # a행렬과 b행렬의 곱\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   23   31\n[2,]   34   46\n```\n:::\n\n```{.r .cell-code}\na %*% solve(a) # a행렬과 a의 역행렬의 곱이므로 단위행렬 나옴 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}