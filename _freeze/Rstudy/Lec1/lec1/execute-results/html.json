{
  "hash": "6f2b1dfcd648dba0764a16516b20d1ed",
  "result": {
    "markdown": "---\ntitle: Lecture 1  \ndate: '2023-01-01'\ncategory: 'Data structure'\ndescription: 'Data 구조'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\nLecture 1 시간에는 데이터의 전반적인 구조에 대해서 알아볼 것입니다.\n\n1.  데이터 구조\n\n    -   벡터 : 1가지 데이터 유형으로 구성된 1차원 구조의 data\n\n    -   행렬 : 1가지 데이터 유형으로 구성된 2차원 구조의 data\n\n    -   배열 : 행렬을 n차원으로 확대한 구조의 data\n\n    -   리스트 : 여러 data 유형으로 구성된 1차원 구조의 data\n\n    -   테이터 프레임 : 리스트를 2차원으로 확대한 구조의 data\n\n2.  데이터 유형\n\n<!-- -->\n\n    -   숫자형 (numberic) :\n\n    -   문자형 (character) :\n\n    -   논리형 (logical) : TRUE 또는 FALSE 으로 이루어진 data\n\n3.  데이터 유형\n\n    -   단일형 데이터 : 숫자형 또는 문자형과 같이 한가지 데이터 유형으로 만 구성된 data(벡터, 행렬, 배열)\n\n    <!-- -->\n\n    -   다중형 데이터 : 숫자형 또는 문자형 데이터 등 여러가지 데이터 유형으로 구성된 data (리스트, 데이터 프레임)\n\n4.  차원에 의한 분류\n\n    -   1차원 데이터 : 1개의 정보\n\n    -   2차원 데이터 : 2개의 정보\n\n    -   3차원 데이터 : 3개의 정보\n\n    -   n차원 데이터 : n개의 정보\n\n-   1차원 + 단일형 --\\> 벡터\n\n-   2차원 + 단일형 -\\> 행렬\n\n-   n차원 + 단일형 -\\> 배열\n\n-   1차원 + 다중형 -\\> 리스트\n\n-   2차원 + 다중형 -\\> 데이터 프레임\n\n5.  숫자형 벡터 : numberic vertor - 실수형 벡터(double) : 정수(양수, 음수), 유리수, 무리수\n\n<!-- -->\n\n    -   정수형 벡터(integer vector)\n\n수치형 벡터는 숫자 값으로 된 벡터다. 스칼라 값은 가장 단순한 수치형 벡터이다.\n\n코드로 예를 들어서 이해해보자!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex1 <- c(1,2,3)\nex1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nmode(ex1) # mode(): 데이터 유형을 확인하는 함수 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nstr(ex1) # str(): 데이터 유형과 값을 확인하는 함수 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nlength(ex1) # length(): 데이터 길이를 확인하는 함수 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ntypeof(ex1) # typeof(): 데이터 유형이 numberic 이라면, integer 인지 double 인지 알려주는 함수/ 즉, mode()함수보다 더 구체적으로 데이터의 유형을 알려주는 함수라고 할 수 있다.  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n6.  문자형 벡터 : charater vector\n\n<!-- -->\n\n    문자형 벡터는 말 그대로 문자열로 된 집합이다. 여기서 문자열은 개별적인 문자 또는 기호가 아니라 this is a string 같은 문자의 집합을 의미한다. 문자형 벡터를 만드는 데 큰따옴표와 작은따옴표를 모두 사용할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex2 <- c(\"dog\",\"tiger\")\n\nex2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\"   \"tiger\"\n```\n:::\n\n```{.r .cell-code}\nex3 <- c(\"1\",\"2\",\"3\")\n\nex3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"3\"\n```\n:::\n\n```{.r .cell-code}\nmode(ex2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nstr(ex2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:2] \"dog\" \"tiger\"\n```\n:::\n\n```{.r .cell-code}\nmode(ex3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nstr(ex3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:3] \"1\" \"2\" \"3\"\n```\n:::\n:::\n\n\n7.  논리형 벡터\n\n<!-- -->\n\n    수치형 벡터와 달리 논리형 벡터는 TRUE 또는 FALSE 값의 집합이다. 이는 기본적으로 논리형 질문에 대한 참/거짓의 답을 의미한다.\n\n    가장 간단한 논리형 벡터는 TRUE 아니면 FALSE 그 자체다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex4 <- c(TRUE,FALSE) \n\nex4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nmode(ex4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\nstr(ex4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n logi [1:2] TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nremove(ex4) # 데이터 세트 삭제하기 -> remove() / rm()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}