{
  "hash": "7b9bf7a94a9714f74cd99a11a3bd0bf6",
  "result": {
    "markdown": "---\ntitle: Lecture 6\nsubtitle: vector(2):index,pre-allocate,벡터끼리 계산, 정규분포 만들기\n---\n\n\n1.  **index: \\[ \\] 사용**\n\n-   **index : 위치, 순서를 의미한다.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\ny <- rep(c(T,F),5)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n# TRUE만 출력\nx[y]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5 7 9\n```\n:::\n\n```{.r .cell-code}\ny2 <- rep(c(F,F,F,F,T),2)\ny2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nx[y2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5 10\n```\n:::\n:::\n\n\n-   Q\\) 3의 배수 찾기\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:30\nb <- a %% 3 # a벡터를 3으로 나눈 나머지를 의미하는 코드이다.  \nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0\n```\n:::\n\n```{.r .cell-code}\n# 3의 배수는 3으로 나누었을 때 나머지가 0이다.\nb == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n[13] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n[25] FALSE FALSE  TRUE FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\na[b == 0] # 3의 배수 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  6  9 12 15 18 21 24 27 30\n```\n:::\n:::\n\n\n-   양의 정수 index 사용\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx  <- 15:25\nx \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 15 16 17 18 19 20 21 22 23 24 25\n```\n:::\n\n```{.r .cell-code}\nx [0] # R이라는 프로그램은 1번째부터 위치가 시작하지만, Python에서는  0번째부터 시작한다. 이 점을 유의해야한다.  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n\n```{.r .cell-code}\nx [1] # 1번째 index \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n\n```{.r .cell-code}\nx [2] # 2번째 index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16\n```\n:::\n\n```{.r .cell-code}\nlength(x) # x벡터의 원소의 개수\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n\n```{.r .cell-code}\nx[11] # 마지막 원소의 위치\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n\n```{.r .cell-code}\nx[c(1,2)] # 1,2번째 index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15 16\n```\n:::\n\n```{.r .cell-code}\nx[c(2,4)] # 2,4번째 index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16 18\n```\n:::\n\n```{.r .cell-code}\nx[c(8:10)] # 8~10번째 index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 22 23 24\n```\n:::\n:::\n\n\n2.  **공간확보(pre-allocate)**\n\n벡터를 먼저 만들고 인덱스를 이용하여 원소를 대입\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- rep(NA,3) # 현재 logical mode이므로 숫자형 데이터를 추가하기 위해서는 형태를 전환시켜야한다. \n\nv <- as.numeric(v)\nmode(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nv[1] <- 1 # v벡터의 1번째 원소를 1로 대입\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 NA NA\n```\n:::\n\n```{.r .cell-code}\nv[2] <- 2\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  2 NA\n```\n:::\n\n```{.r .cell-code}\nv[3] <- 3\n\n# 위의 코드를 하나의 코드로 만들면? \nv[c(1:3)] <- c(1,2,3)\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n-   **벡터 이름 부여하기**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nnames(v) <- c(\"R\",\"Markdown\",\"Quarto\")\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       R Markdown   Quarto \n       1        2        3 \n```\n:::\n:::\n\n\n3.  **벡터끼리 계산**\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:5 \na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\na+5 # a벡터의 모든 원소에 5가 더해진다. \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\na*3 # 3이 곱해진다.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  6  9 12 15\n```\n:::\n\n```{.r .cell-code}\na/5 # 5가 나뉘어진다.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2 0.4 0.6 0.8 1.0\n```\n:::\n\n```{.r .cell-code}\n# 루트(root)\n# R에서는 root를 사용하려면 sqrt()라는 함수를 사용해여한다. \nsqrt(a) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.000000 1.414214 1.732051 2.000000 2.236068\n```\n:::\n\n```{.r .cell-code}\nb <- c(1,4,9,16,25)\nsqrt(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# 평균(mean) \na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nmean(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  4  9 16 25\n```\n:::\n\n```{.r .cell-code}\nmean(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n\n```{.r .cell-code}\n# 총합(sum)\nsum(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n\n```{.r .cell-code}\nsum(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55\n```\n:::\n\n```{.r .cell-code}\n# 같은 위치끼리 계산된다. \na <- 1:3\nb <- 4:6\nc <- 7:10\n\na+b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 7 9\n```\n:::\n\n```{.r .cell-code}\na-b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3 -3 -3\n```\n:::\n\n```{.r .cell-code}\na*b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4 10 18\n```\n:::\n\n```{.r .cell-code}\na/b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.25 0.40 0.50\n```\n:::\n\n```{.r .cell-code}\n# 원소의 개수가 안맞은 벡터와 사칙연산을 할 경우 다음과 같은 에러가 뜨면서 Recycling rule에 의해서 1+10 = 11이 마지막원소로 나오게 된다.\na+c \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in a + c: longer object length is not a multiple of shorter object\nlength\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  8 10 12 11\n```\n:::\n:::\n\n\n4.  **정규분포 만들기**\n\n::: callout-note\n## 정규분포\n\n편차 / 표준편차\n\n\\[자료- 평균(자료)\\] / 표준편차(자료)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 1:5\nmean(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nz <- (n-mean(n))/sd(n) # z는 정규분포\nz \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.2649111 -0.6324555  0.0000000  0.6324555  1.2649111\n```\n:::\n\n```{.r .cell-code}\nmean(z) # 정규분포의 평균은 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nvar(z) # 정규분포의 분산은 1이다.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}