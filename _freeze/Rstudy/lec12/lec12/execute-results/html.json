{
  "hash": "8828835b52835199a0fcfb94c543eebe",
  "result": {
    "markdown": "---\ntitle: Lecture 12\ndate: '2023-01-12'\ndescription: '데이터 프레임(Data Frame)'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n### 차례\n\n-   데이터 프레임(Data Frame)\n\n    -   변환\n\n-   Data Frame 만들기\n\n-   indexing\n\n-   pre - allocate\n\n1.  **데이터 프레임(Data Frame)**\n\n-   SQL의 table = R의 Data Frame\n\n-   list의 모임이며, 하나의 list가 열(column)이다.\n\n-   같은 열끼리는 같은 type 이어야 한다.\n\n-   제약 조건: 원소의 길이가 같아야한다.\n\n-   변환\n\n    -   Vector --\\> factor : 벡터의 특별한 형태\n\n    -   Array --\\> matrix\n\n    -   list --\\> data.frame : list의 특별한 형태\n\n    -   list는 각각의 원소들의 type이 같은 필요가 없다.\n\n    -   data.frame은 각각의 원소들의 type이 같아야한다. (column별)\n\n        -   그래서 특별한 형태라는 것!!\n\n    -   list는 vector, factor, array, matrix, list, data.frame 가능!\n\n2.  **data.frame 만들기**\n\n`data.frame(열이름1=원소, 열이름2=원소2,….)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 데이터 프레임 만들때 열의 이름과 원소 같이 생성하는 경우\ndf <- data.frame(x =1:3, y =c('a','b','c'), z=3*1:3)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y z\n1 1 a 3\n2 2 b 6\n3 3 c 9\n```\n:::\n\n```{.r .cell-code}\nx <- 4:6\ny <- letters[x]\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"d\" \"e\" \"f\"\n```\n:::\n\n```{.r .cell-code}\nz <- 3*x\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12 15 18\n```\n:::\n\n```{.r .cell-code}\n# 데이터 프레임 만들기 전에 먼저 열들의 변수를 만든 후 데이터 프레임을 생성하는 경우\ndf2 <-data.frame(x,y,z) \ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y  z\n1 4 d 12\n2 5 e 15\n3 6 f 18\n```\n:::\n:::\n\n\n3.  **indexing**\n\n-   **list index : class의 변화에 대해 주목!**\n\n**data.frame의 indexing에는 list index 방법과 matrix index 방법이 존재한다.**\n\n**두 개의 index에는 차이가 존재한다. 차이는 밑의 코드를 보면서 알 수 있을 것이다.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y z\n1 1 a 3\n2 2 b 6\n3 3 c 9\n```\n:::\n\n```{.r .cell-code}\nl.df <- df[[1]]\nl.df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nclass(l.df) # vector \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nl.df2 <- df[1]\nl.df2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x\n1 1\n2 2\n3 3\n```\n:::\n\n```{.r .cell-code}\nclass(l.df2) # data.frame 형태로 출력된다. \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nl.df3 <- df['x'] \nl.df3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x\n1 1\n2 2\n3 3\n```\n:::\n\n```{.r .cell-code}\nclass(l.df3) # data.frame 형태로 출력된다. \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nl.df4 <- df[c(1,3)]\nl.df4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x z\n1 1 3\n2 2 6\n3 3 9\n```\n:::\n\n```{.r .cell-code}\nclass(l.df4) # data.frame 형태로 출력된다. \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n\n-   matrix index : \\[행,열\\]\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y z\n1 1 a 3\n2 2 b 6\n3 3 c 9\n```\n:::\n\n```{.r .cell-code}\nm.df <- df[1,1] #1행 1열\nm.df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nclass(m.df) # 1이라는 interger 출력 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nm.df2 <- df[,1] # 1열 추출\nm.df2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nclass(m.df2) # 숫자형 벡터 출력\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nm.df3 <- df[,2] # 2열 추출 \nm.df3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\"\n```\n:::\n\n```{.r .cell-code}\nclass(m.df3) # 문자형 벡터 출력\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nm.df4 <- df[,-3] # 1,2열 추출 \nm.df4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\n1 1 a\n2 2 b\n3 3 c\n```\n:::\n\n```{.r .cell-code}\nclass(m.df4) # data.frame 추출\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nm.df5 <- df[1:2,] # 1,2행 추출\nm.df5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y z\n1 1 a 3\n2 2 b 6\n```\n:::\n\n```{.r .cell-code}\nclass(m.df5) # data.frame 추출\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n\n4.  **pre - allocate : 미리 공간만들어서 그 곳에 원소 넣기**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 3\n\ndf <- data.frame(x = numeric(n), y = character(n), z = 0)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y z\n1 0   0\n2 0   0\n3 0   0\n```\n:::\n\n```{.r .cell-code}\n## list index 방법 \ndf[[1]] <- 1:3 # 1열의 원소에 1:3이라는 숫자형 벡터 기입\ndf \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y z\n1 1   0\n2 2   0\n3 3   0\n```\n:::\n\n```{.r .cell-code}\n# 2열의 원소에는 내장 데이터 letter을 이용하여 a b c 기입\ndf[[2]] <- letters[df[[1]]] \ndf$y <- letters[df[[1]]] # 위 코드와 동일한 의미\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y z\n1 1 a 0\n2 2 b 0\n3 3 c 0\n```\n:::\n\n```{.r .cell-code}\n## matrix index 방법 \n# 3열은 1열의 숫자형 벡터의 3배수\ndf[,3] <- 3*df[[1]]\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y z\n1 1 a 3\n2 2 b 6\n3 3 c 9\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}