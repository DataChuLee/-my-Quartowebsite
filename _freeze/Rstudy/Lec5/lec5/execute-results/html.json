{
  "hash": "14efb132b932f44981f057e15baaf0d8",
  "result": {
    "markdown": "---\ntitle: Lecture 5 \nsubtitle: vector(1):숫자형, 문자형 벡터 생성 및 seq()함수, rep()함수 \n---\n\n\n### 차례\n\n-   벡터\n\n<!-- -->\n\n    -   숫자형 벡터\n\n    -   문자형 벡터\n\n-   c( ) : 벡터 생성\n\n-   seq(시작, 끝, 증가량)\n\n-   rep(반복할 숫자, 반복 횟수)\n\n-   paste(문자1, 문자2, sep)\n\n-   Logistic vector\n\n1.  **Vector(벡터)**\n\n    R에서는 길이 1의 벡터(스칼라)\n\n    실제로는 세로이지만, 프로그램상 가로로 보이는 것뿐이다.\n\n2.  **벡터생성 : c( )**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\na <- c(x,4,5)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# 문자형은 따옴표(\"\",'')를 사용하여 벡터를 생성한다.\ny <- c(\"a\",\"b\",\"c\")\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\"\n```\n:::\n:::\n\n\n-   벡터의 원소는 같은 자료형만 허용\n\n    -   벡터는 숫자 or 문자형만 있어야한다. (숫자, 문자 같이 허용 안된다)\n\n    -   숫자와 문자형이 같이 있는 벡터를 생성할 경우 모두 문자형으로 표현된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,\"대한민국\")\nx # 숫자인 1과 2도 문자형으로 표현되는 것을 알 수 있다.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"        \"2\"        \"대한민국\"\n```\n:::\n:::\n\n\n3.  **sequence(시작, 끝, 증가량)**\n\n숫자형 벡터에서만 사용된다.\n\n증가량의 default 값은 1이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(0,10) # 0부터 10까지의 연속된 수의 배열. 즉, 수열이 형성\nx \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nx <- seq(0,10,2) # 0부터 10까지 짝수로만 이루어진 수열이다. 공차가 2 \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0  2  4  6  8 10\n```\n:::\n\n```{.r .cell-code}\nx <- seq(1,10,2) # 홀수로 이루어진 수열\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5 7 9\n```\n:::\n\n```{.r .cell-code}\n# 시작: 끝 (무조건 1씩 증가하는 수열이다)\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\ny <- 10:1 # 시작을 끝보다 큰 수로 잡으면 감소하는 수열이 형성된다.\ny \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 10  9  8  7  6  5  4  3  2  1\n```\n:::\n\n```{.r .cell-code}\nc <- 25:35 # 시작이 25 끝 35까지 1씩 증가하는 수열\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 25 26 27 28 29 30 31 32 33 34 35\n```\n:::\n:::\n\n\n4.  **rep(반복할 숫자, 반복 횟수)**\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    rep(1,3) # 1을 3번 반복해줘!\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1 1 1\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    rep(seq(1,3),2) # 1,2,3을 2번 반복해줘! \n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1 2 3 1 2 3\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    rep(1:3,2) # 위와 같은 의미의 코드 \n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1 2 3 1 2 3\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    rep(\"git\",2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"git\" \"git\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    rep(c(\"g\",\"i\",\"t\"),2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"g\" \"i\" \"t\" \"g\" \"i\" \"t\"\n    ```\n    :::\n    :::\n\n\n5.  **paste(문자1, 문자2, sep)**\n\n문자형 벡터에서 사용한다. 문자끼리 연결해주는 함수\n\n-   sep : 문자간의 공간을 어떻게 할 건지 결정해준다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"git\",\"hub\") # sep 인자의 default 값은 한칸 띄어쓰기이다. \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"git hub\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"git\",\"hub\",sep =\" \") # 위와 같은 의미의 코드이다 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"git hub\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"git\",\"hub\",sep =\"\") # sep = \"\" \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"github\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"git\",\"hub\",sep =\"*\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"git*hub\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"git\",\"hub\",sep =\"//\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"git//hub\"\n```\n:::\n\n```{.r .cell-code}\npaste(rep(\"X\",5),1:5, sep = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"X1\" \"X2\" \"X3\" \"X4\" \"X5\"\n```\n:::\n\n```{.r .cell-code}\ndate()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Mon Jan  9 02:53:13 2023\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"Today is\",date())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Today is Mon Jan  9 02:53:13 2023\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"대한민국\",\"2023년 기준\", \"축구순위는 25위이다\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"대한민국 2023년 기준 축구순위는 25위이다\"\n```\n:::\n:::\n\n\n6.  **Logistic vector**\n\n    TRUE, FALSE 로 이루어진 벡터이다. 파이썬에서는 논리값벡터를 불린 값으로 불린다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n100 > 95\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n3>5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\na <- 3\nb <- 1+2\na == b # R에서는 좌변과 우변이 같다라는 의미를 '=='로 표현한다.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\na != b # '!=' 는 not 을 의미한다.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\na <- c(1,2,3)\na == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\na <- c(\"x1\",\"x2\",\"x3\")\na == \"x3\" \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}