{
  "hash": "5e24b84d9125ec1d213559568ff80e09",
  "result": {
    "markdown": "---\ntitle: Lecture 11\ndate: '2023-01-11'\ndescription: 'list : 생성, index, sublist, pre-allocate'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n### 차례\n\n-   list 만들기\n\n-   list index\n\n-   sublist\n\n-   pre-allocate\n\n1.  **list 만들기**\n\n`list` 는 모든 타입을 원소로 가질 수 있다.\n\ncf) 벡터는 같은 타입끼리만 생성 가능!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nli <- list(c(1,2,3),\"abc\",mean) # 모든 자료형을 가질 수 있다. \nli\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"abc\"\n\n[[3]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\n# list에 이름부여\nli_name <- list(a = c(1,2,3), b = c('a','b','c'), c = mean)\nli_name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\" \"b\" \"c\"\n\n$c\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n:::\n\n\n2.  **list index**\n\n-   \\[ \\] , \\[ \\[ \\] \\] 이용\n\n\n::: {.cell}\n\n```{.r .cell-code}\nli\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"abc\"\n\n[[3]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nli[1] # 1번째 list \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nli[[1]] # 1번째 list에 속해 있는 숫자형 벡터\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nli[2] # 2번째 list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"abc\"\n```\n:::\n\n```{.r .cell-code}\nli[[2]] # 2번째 list에 속해 있는 문자형 벡터\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"abc\"\n```\n:::\n\n```{.r .cell-code}\nli[3] # 3번째 list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nli[[3]] # 3번째 list에 속해 있는 function \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nli[[1]][1] # 1번째 list에 속해 있는 숫자형벡터 中 1번째 index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nli[[1]][2] # 1번째 list에 속해 있는 숫자형벡터 中 2번째 index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nli[[1]][3] # 1번째 list에 속해 있는 숫자형벡터 中 3번째 index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nli_name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\" \"b\" \"c\"\n\n$c\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nli_name[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nli_name[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$b\n[1] \"a\" \"b\" \"c\"\n```\n:::\n\n```{.r .cell-code}\nli_name[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$c\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nli_name[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nli_name[[1]][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\n# list에 이름이 주어졌을 떄!\n# 숫자 대신에 이름을 기입하면 된다! (단, 문자형이라면 ' '(따옴표) 처리를 해야한다.)\nli_name[['a']] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nli_name$a \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nli_name[['b']] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\"\n```\n:::\n\n```{.r .cell-code}\nli_name$b \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\"\n```\n:::\n\n```{.r .cell-code}\nli_name[['c']]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nli_name$c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nli_name[[1]][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nli_name[['a']][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nli_name$a[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n3.  **sublist**\n\n**list**에서 sub 뽑아도 **list** 이다.\n\n-    list\\[ \\]: list 한 덩어리이다. (**list**)\n\n-   list\\[\\[ \\]\\]: list 내의 벡터이다.(**원소**)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nli\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"abc\"\n\n[[3]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nli[1] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nmode(li[1]) # list \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nli[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nmode(li[[1]]) # numeric vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nmode(li[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nmode(li[[3]]) # function \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n```{.r .cell-code}\nli[1:2] # 1~2번째 list \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"abc\"\n```\n:::\n\n```{.r .cell-code}\nli[c(1,3)] # 1,3번째 list \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nli_sub <- li[c(1,3)]\nli_sub\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nlength(li)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nlength(li_sub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n4.  **pre-allocate**\n\n-   '미리 만들어 놓는다' 라는 의미이다.\n\n-   **list**를 만들고 이후에 data를 넣는다.\n\n-   속도향상 및 for 구문 등에 활용!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist() # 빈 list \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlist()\n```\n:::\n\n```{.r .cell-code}\nlst <- vector('list',3) \nlst # 빈 리스트가 3개 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\nNULL\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n```\n:::\n\n```{.r .cell-code}\nlst[[1]] <- c(1,2,3) # 1번째 list에 속해 있는 vector\nlst[[2]] <- 'abc' # 2번째 list에 속해 있는 vector\nlst[[3]] <- mean # 3번째 list에 속해 있는 function\nlst \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"abc\"\n\n[[3]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\n# 만약 list안에 새로운 list를 만들고 싶다면, 아래와 같이 코드를 기입하면 된다. \nlst[['a']] <- c(4,5,6)\nlst\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"abc\"\n\n[[3]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x00000288febf00e0>\n<environment: namespace:base>\n\n$a\n[1] 4 5 6\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}