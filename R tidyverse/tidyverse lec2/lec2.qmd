---
title: R tidyverse lec2
date: '2023-01-23'
description: 'dplyr 패키지 중급 기술'
categories: 'dplyr'
execute: 
  message: false
  warning: false
editor_options: 
  chunk_output_type: console
---

### dplyr의 고급 동사들

엑셀파일에서 만들어진 테이블을 R로 연결시키는 방법!

`install.packages('datapaste')` 한 다음 엑셀의 테이블을 복사한 다음

Addins에서 data paste를 클릭!

### 2개의 테이블을 연결하는 방법

### 테이블 합치기

-   `left_join(x,y)` : 테이블을 왼쪽으로 합쳐줘. **(x \<-y)**

**옵션들**

-   `by` : 합칠떄의 기준열

    -   `by = c('col1', 'col2')`

```{r}
# 데이터 테이블 생성하는 방법
library(tidyverse)
tab_a <- tibble(id = c(1,2,3,4),
                score = c(35,70,63,80))
tab_b <- tibble(id = c(1,2,3,4),
                name = c('Lee','jelly','soony','Park'))

# id정보를 기준으로 테이블 2개 합치기
tab_a %>% left_join(tab_b, by = 'id')
```

### 테이블 합치는 방법 종류

합치는 방법도 여러가지이다.

-   **Mutating joins** : 두 테이블을 하나의 테이블로 합체 `::` 기준은 왼쪽 테이블!

    -   `left_join()` : 가장 중요하다!

    -   `right_join()`

    -   `inner_join()` : 유용하다!

    -   `full_join()` : 유용하다!

### `left_join()` : 왼쪽으로 합쳐서 테이블 생성

```{r}
left_join(tab_a,tab_b) %>% print()
```

### `right_join()` : 오른쪽으로 합쳐서 테이블 생성

```{r}
right_join(tab_a,tab_b) %>% print()
```

### `inner_join()` : 교집합 만 뺴서 테이블 생성

```{r}
inner_join(tab_a,tab_b)
```

### `full_join()` : 모든 데이터 보존하는 테이블 생성

```{r}
full_join(tab_a,tab_b) %>% print()
```

```{r}
tab_a <- tibble(id=c(1,3,4,5),
                score=c(35,70,63,80))
tab_b <- tibble(id2=c(1,2,3,4),
                name=c("Lee","jelly","soony","Park"))

# 테이블 합칠 떄 컬럼이 다른 경우 by 옵션을 이용하여 합치는 방법! 
# 왼쪽 테이블을 기준으로 합치기 때문에 id가 2인 부분은 없으며, 5인 부분은 name이 NA이다. 
left_join(tab_a,tab_b, by =　c('id'='id2'))
```

-   **Filtering joins : 하나의 테이블을 다른 테이블로 필터!**

### `semi_join()` : 매칭 데이터 보존 테이블 생성

```{r}
tab_a <- tibble(id = c(1,2,3,4),
                score = c(35,70,63,80))
tab_b <- tibble(id = c(1,2,3,4),
                name = c('Lee','jelly','soony','Park'))

semi_join(tab_a,tab_b)
```

### `anti_join()` : 매칭 데이터 제거 테이블 생성

```{r}
anti_join(tab_a,tab_b)
```

#### 대칭차집합은 어떻게? (A-B) U (B-A)

```{r}
a <- tab_a %>% anti_join(tab_b) # A-B
b <- tab_b %>% anti_join(tab_a) # B-A

full_join(a,b) # 대칭 차집합
```

### 이동 데이터로 실습하기

#### 시도 정보를 moving_data에 합쳐보세요!

```{r}
# 데이터 로드
reference_data <- readxl::read_excel("reference.xlsx")
moving_data <- read_csv("seoul_moving_202107_09_hr.csv")

# 변수 이름 수정
reference_data <- reference_data %>% janitor::clean_names()
moving_data <- moving_data %>% janitor::clean_names()

reference_data %>% glimpse()
moving_data %>% glimpse()
```

#### 문제1. moving data에 시도 정보와 name, full name 붙이기

```{r}
left_join(moving_data, reference_data, 
          by = c('chulbal_sigungu_kodeu' = 'sigungu'))
```

#### 

#### 문제 2. 서울시에서 출발한 trip만 필더링?

```{r}
moving_data %>% 
  left_join(reference_data, 
            by = c('chulbal_sigungu_kodeu'= 'sigungu')) %>% 
  filter(sido == 11000)
```

### `mutate()` 심화학습

궁합좋은 함수들

#### 만들 위치 지정

-   만들 위치 지정하기

    -   `.after` , `.before` 옵션

```{r}
tab_a %>% 
  mutate(ranking = rank(score), .after = 'id')

tab_a %>% 
  mutate(ranking = rank(score), .before = 'id')

tab_a %>% 
  mutate(ranking = rank(-(score)), .before = 'id')

```

#### 빈칸(NA)과 관련한 함수들

-   `NA` 와 관련한 함수들

    -   `na_if()`

    -   `coalesce()`

    -   `replace_na()` : `tidyr` 패키지 함수이다.

```{r}
# y의 원소중 빈칸이 있으면 NA로 처리해줘!
y <- c("a", "b", "", "c")
y_na <- na_if(y, "")
y_na

# NA인 원소를 hi로 
coalesce(y_na, "hi")

# y_na의 1번째 원소를 NA로 바꾼다음, coalesce()함수를 이용하여
# NA인 원소를 문자형 타입의 숫자로! 
y_na[1] <- NA
coalesce(y_na,as.character(1:4))

# y_na의 원소를 NA인 애들을 hello로! 
replace_na(y_na, "hello") 
```

### `if_else()` : 특정 조건으로 값 만들기

```{r}
tab_a <- tab_a %>% 
  mutate(ranking = rank(score),
         .after = 'score')


tab_a <- tab_a %>% 
      mutate(
        status = if_else(
              ranking < 3,
              "high",
              "low"),
          .after = "ranking")
tab_a
```

#### NA를 입력하고 싶을 때는? 그냥 NA라고 입력하면 오류가 난다.

```{r}
# NA_character_ --> NA로 출력됨
tab_a %>%  
    mutate(
        status = if_else(ranking < 3,"low", NA_character_),
        .after = "ranking")

```

### `case_when()` : 조건 여러개로 값 만들기

```{r}
# case_when()
# TRUE --> else로 출력 / FALSE --> NA로 출력
tab_a %>% 
    mutate(
        status = case_when(
            ranking == 1 ~ "leader",
            ranking < 3 ~ "followers",
            ranking == 3 ~ "third",
            TRUE ~ "else"),  
        .after = "ranking"
    )

tab_b <- tab_b %>% 
  mutate(ranking = rank((id)),
         .after = "id")

tab_b %>% 
  mutate(id_rank = case_when(
    ranking == 1 ~ 'leader',
    ranking < 3 ~ 'followers',
    ranking == 3 ~ 'third',
    TRUE ~ 'else'),
    .after = 'ranking'
    )
```

### Q) 이동시간을 시간단위로 바꿔 새로운 변수를 만들어보세요.

`trip_time_hr` 이름 사용

`trip_time_hr` 을 이용해서 `trip_time_class`를 **short, middle, long** 으로 분류하는 컬럼을 만들어보세요.

**30분 이내 (short) , 30\~1시간(middle), 그 이상(long)**

```{r}
moving_data <- moving_data %>% 
  mutate(trip_time_hr = pyeong_gyun_idong_sigan_bun/60,
         trip_time_class = case_when(
           trip_time_hr < 0.5 ~ 'short',
           trip_time_hr <1 ~ 'middle',
           TRUE ~ 'long'
         )) %>% 
  relocate(trip_time_hr,trip_time_class)
```

### 

### 그룹 데이터 다루기

`group_by()` 를 이용한 그룹별 내용 요약

-   groupping이 된 tibble은 프린트를 하면 표시가 됨.

    -   이러한 그룹 변수를 사용해서 궁합이 좋은 함수들이 있다.

    -   `arrange(), count(), tally()`

```{r}
tab_a <- tab_a %>% 
  group_by(status)
tab_a # group data 
```

#### `count()와 tally()`

`count() == group_by() + tally()`/ 그룹핑이 되어있으면 tally()/ 안되어 있으면, count()를 사용해라!

```{r}
tab_a %>% 
    tally() # tally? 무슨 뜻? -> '바를 정'을 사용한 카운팅! 
tab_a %>% 
    ungroup() %>% 
    count(status)
```

#### `arrange()` 함수와의 궁합

```{r}
# 단순히 id를 기준으로 오름차순 배열을 한 것이다. 
tab_a %>% 
  arrange(id) %>% 
  print()

# 오름차순으로 배열을 하는데, 그룹별로 보여달라는 의미이다. 
# .by_group = T 
tab_a %>% 
  arrange(id, .by_group = T) %>% 
  print()
```

#### 그룹 키와 그룹 해제

-   `group_keys()` : 현재 묶인 그룹의 unique값을 보여준다.

-   `ungroup()` 을 사용해서 그룹을 해제할 수 있다.

```{r}
tab_a %>% group_keys()
tab_a # group화가 되어 있는 상태이다. 

tab_a %>% ungroup() # group화 해제된 상태
```

### 실습하기

**Q) 서울시에서 short trip이 가장 많이 일어나는 구는?**

```{r}
# 우선 moving data와 refence data를 조인하고 시작해야한다. 
# 그런 다음 우리가 문제에서 구해야하는 것은 두가지이다. 
# 1번째는 short trip을 따로 필터 , 2번째는 가장 많이 일어나는 구
# 1번째 --> filter 함수 이용 / 2번째 --> 'name'을 group() + tally() 
moving_data %>% 
  left_join(reference_data,
            by = c('chulbal_sigungu_kodeu' = 'sigungu')) %>% 
  filter(trip_time_class == 'short') %>% 
  group_by(name) %>% 
  tally() %>% 
  arrange(desc(n)) %>% 
  slice_max(n)

moving_data %>% 
  left_join(reference_data,
            by = c('chulbal_sigungu_kodeu' = 'sigungu')) %>% 
  group_by(trip_time_class, name) %>% 
  tally() %>%
  filter(trip_time_class == 'short') %>% 
  arrange(desc(n)) %>% 
  slice_max(n)
```
